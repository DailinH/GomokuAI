## Improvements Accumulated

### Week 3

我们目前的Core模块版本相对于之前的几个比较大的版本，累积了如下的改进：

#### Board类：时空开销决策

* 最初，我们考虑到了「蒙特卡洛树是很适合做多线程的」这一特点，便自然想在代码设计时对这一特性加以利用。并行处理中最重要的一点就是线程安全，而为了保证这点，在每次迭代中单独拷贝一份Board对象出来是一种不错的做法。

  因此，在最初的Board类的设计中，我们的做法是使Board的拷贝成本尽量低。但这对结构的设计与性能的优化带来了不小的考验。

  查阅相关资料得知，最终的比赛平台Botzone提供的机器CPU为单核，故对AI下棋这种「计算密集型」任务，多线程处理并不会带来什么收益。因此，就算我们利用多线程版本来加速AI的训练，最终比赛时还是需要提交一份高性能的单线程版本代码。

  经过权衡以后，我们最终的选择是：无视棋盘的空间开销，写一个单线程、优化到极致性能的Board类，并保证一盘棋局中Board经过初始化后，永远不会被拷贝。至于并行化处理功能，由于AI的训练是计算密集型任务，能开的线程数量大致等于CPU的核心数，因而在不同的CPU核上分别开几个Board进行训练即可。

#### Board类：存储结构改进

* 最初，在我们定下来「写高性能、不在意空间开销的Board类」的设计方针后，我们使用了哈希表来作为棋盘的核心存储结构：

    ```cpp
    std::unordered_map<Position, Player> m_appliedMoves;
    std::unordered_set<Position> m_availableMoves;
    ```

    哈希表有着无需存下整个棋盘位置，并且能在O(1)时间内根据位置索引到状态的优势，因此我们一开始认为使用它的效率会很高。但是，经过Profiler的测试，我们发现STL哈希表相关的接口占用了相当巨大的开销，而且这些接口的调用是完全无法避免的。

    因此，我们决定更换一个存储容器。经过仔细的分析，我们最终选择了`std::array`，并作了如下的设计：

    1. 将棋盘盘面切割为三个不同的状态数组，每个数组记录了棋盘的所有位置。但是，我们不存棋盘上某个位置现在是什么棋子（状态），而是存「某个棋子（状态）是否放置在某个位置上」。

       也就是说，曾经的检索顺序是Position->Player，现在的检索顺序是Player->Position->true or false。

       这样做有不少的好处。首先是**棋盘状态的检索及修改可以变得非常快**：不管采用何种检索方案，都是真正的随机访问（数组下标索引），而状态的修改仅仅涉及到了布尔值的修改。以及，按照一些资料所述，**这种结构（One-hot编码）更适合用来表述神经网络**[[1]](#Literatures Reference)。

    2. 额外添加一个数组，用以记录每个棋子（状态）在棋盘中已经有了多少（即每个状态数组中值为true的元素数量）。这避免了每次求棋盘空位数量时，对数组进行的遍历。

    这种设计无疑会让Board的体积进一步膨胀。但是，考虑到现在Board变成了一个纯栈上对象（数组为静态栈上数组），在拷贝时反而会得到一定的优化。此外，若实在对体积有所要求，存储容器也可由`std::array`改为`std::bitset`，因为在目前的棋盘设计下，后者就是前者的紧凑版本。

> 关于Profiler的具体测试结果，请参阅*Performance Profile*中的[*Profiler Report*](#Profiler Report)章节。
>
> 关于详细的时空开销分析，请参阅*Performance Profile*中的[*Cost Analysis*](#Board 时空开销分析)章节。

### Week 5

相对于前一个版本，此阶段我们主要累积了一些工程上的改进，如Node，Policy，MCTS类的开放性结构设计。

详情请见Week7报告。