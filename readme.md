## MCTS

* 一开始认为可以用来生成棋谱
* 每次需不需要保存一点以前的东西？

### 关于并行处理的决策

由于蒙特卡洛树的特性是很适合做多线程的，我们便自然想到要不要对代码进行并行化处理。但这又衍生出来了若干问题：

* 为了保证线程安全，将每份Board拷贝一份独立处理不可或缺，而这便要求Board类对象的拷贝成本需尽量低。这对结构的设计以及相关性能优化提出了不小的考验。

查阅相关资料得知，最终的比赛平台Botzone提供的机器CPU为单核，因此对于AI下棋这种计算密集型任务，多线程处理并不会带来什么收益，写一份高性能的单线程版本代码是必要的。

因此，做并行化处理主要的期望是能提高AI的训练速度。经过思考后，我发现可以这样做：写一个单线程高性能，但拷贝代价较大的Board类，同时保证一盘棋局中Board经过初始化后始终不会被拷贝。对并行化处理部分，只需通过多核同时开多盘棋局训练即可。



## Task List

### Accomplished

- [x] 游戏棋盘与基本规则
- [x] MCTS基本结构
- [x] Cpp版简单的Botzone接口程序

### WIP

- [ ] 为Core模块编写测试代码
- [ ] 序列化蒙特卡洛树

### To-do

- [ ] 更加模块化的Botzone交互接口
- [ ] 将Core模块进一步封装为Python包



## 第三方库使用

### C++

* gtest（Adapter先装扩展再装vs_installer)
* boost::python
* jsoncpp